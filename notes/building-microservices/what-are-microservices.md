什么是微服务
=======

微服务是协同工作的小型自管理的服务。

> Microservices are small, autonomous services that work together.

# 小并专注于做好一件事情

当我们编写代码来添加新的功能时，code base会随之增长。假以时日，由于code base太大，我们很难知道到底哪里需要修改。

对于单片结构，即使原有的code base是清晰而模块化的，也会由于内部边界被随意打破而失控。类似功能的不同代码在系统中扩散，使得修复bug和修改实现越来越困难。

在单片系统中，我们通过确保代码的内聚性来对抗这个趋势。当我们思考微服务时，内聚性(让相关代码组织在一起的驱动力)是一个重要理念。这个理念在 Robert	C.	Martin的单一职责准则(Single Responsibility Principle)的定义中被再次强化，被表述为“聚合因同一理由变化的东西，分离因不同理由而变化的东西”。

> Gather together those things that change for the same reason, and separate those things that change for different reasons.

微服务采用相同的方式来处理不相关的服务。基于业务边界我们制定服务的边界，这使得边界清晰可见，代码集中于特定的功能。并且，通过限制服务在显式的边界内，我们避免了服务膨胀到太大的可能。

## how small is small

经常被问到的一个问题: 到底小是多小？小到什么程度合适？

- 直接用代码行数来评定是不合适的

    因为有些编程语言比其他语言更善于表述，从而只需要很少的代码行数。另外我们必须考虑我们会引入很多的依赖，这些依赖包含了大量的代码。此外，领域中的某些部分可能就是额外的复杂不得不需要更多的代码。

- 微服务应该可以在两周内重写一遍

    这是一个不错的判断方式，比较直观。具体实施时可能三周甚至四周都是可以接受的，但是如果发现需要更多的时间，那么需要警惕。

- 小到不能再小就是足够小

    这个判断方式稍微偏激点。对于大多数情况，通常都是觉得系统太大而打算拆分。一般我们对系统太大是比较有感觉的，一旦我们觉得一段代码不再感觉太大，通常是已经拆到足够小了。

- 和团队组织结构有关

    这是一个非常强力的判断依据。通常我们的团队会是基于agile或者scrum的团队，组织结构会偏小(一般小团队三五人，普通团队七八人)。当我们发现codebase太大以至于无法被这样的小团队轻松而有效管理时，拆分就是很自然的事情。但是这又涉及到和公司的组织结构，还有企业文化。

- 收益和代价之间的均衡

    服务拆分的越小，我们从微服务架构中得到的收益越大，比如减少内部耦合，减少代码重复。但是也要付出一些代价: 多次远程调用的性能开销，系统集成的复杂度。

TDB: 将PPT的内容放进来。




